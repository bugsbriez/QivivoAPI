import sys
from .qdevices import *
from .habitation import *
import urllib.request
import urllib.parse
import urllib.error
import json


class API:
    """
    Class implementing API handler and basic operations.

    Attributes :
    client_id : str
        ID generated on Qivivo website
    client_secret : str
        Secret generated on Qivivo website
    token : str
        OAuth token generated by Qivivo access server
    token_date : datetime
        datetime of the creation of the token, used to determine if token is still valid
    oauth_url : str
        Access server of Qivivo
    api_url : str
        resources server of Qivivo
    device : []
        list of device return by resources server

    Methods:
    get_devices()
        return the list of devices, update it if necessary
    refresh_devices()
        force the update of the devices list
    get_device_by_uuid(uuid : str)
        return the device object corresponding tu the uuid
    get_habitation()
        return the habitation object link to the used account
    """
    client_id: str = None
    client_secret: str = None
    token: str = None
    token_date: datetime = None
    oauth_url: str = 'https://account.qivivo.com/oauth/token'
    api_url: str = 'https://data.qivivo.com/api/v2/'
    devices = []
    logging.basicConfig(stream=sys.stderr, level=logging.ERROR)

    def __init__(self, clientID: str, clientSecret: str) -> None:
        """
        init the API object with
        :param clientID: str
        :param clientSecret: str
        """
        self.client_id = clientID
        self.client_secret = clientSecret
        self.get_token()
        logging.debug('QivivoAPI: object created')
        return

    def get_token(self) -> None:
        """
        Get the token from Qivivo access server and initialise the token creation date
        :return:
        """
        logging.info('QivivoAPI: Asking for token')
        send_data = urllib.parse.urlencode({'grant_type': 'client_credentials',
                                            'client_id': self.client_id,
                                            'client_secret': self.client_secret,
                                            })
        send_data = send_data.encode('ascii')
        try:
            r = json.load(urllib.request.urlopen(self.oauth_url, send_data))
        except urllib.error.HTTPError as e:
            logging.error("QivivoAPI: urllib error: " + e.reason)
            logging.error("QivivoAPI; API error: " + e.read())
        self.token = r['access_token']
        self.token_date = datetime.now()
        logging.info('QivivoAPI: token initialised with: ' + self.token)
        return

    def check_token(self) -> None:
        """
        Check if the token is still valid, renew it if not
        :return:
        """
        logging.debug('QivivoAPI: test if token is less than 30mn')
        used = datetime.now() + timedelta(minutes=30)
        if self.token_date > used:
            logging.debug('QivivoAPI: renew token')
            self.renew_token()
        else:
            logging.debug('QivivoAPI:token still OK')
            return

    def renew_token(self) -> None:
        """
        Renew the token and set the creation date
        TODO When Qivivo give access, replace by a real OAuth renew token
        :return:
        """
        logging.debug('QivivoAPI: Asking for token')
        send_data = urllib.parse.urlencode({'grant_type': 'client_credentials',
                                            'client_id': self.client_id,
                                            'client_secret': self.client_secret,
                                            })

        send_data = send_data.encode('ascii')
        try:
            r = json.load(urllib.request.urlopen(self.oauth_url, send_data))
        except urllib.error.HTTPError as e:
            logging.error("QivivoAPI: urllib error: " + e.reason)
            logging.error("QivivoAPI; API error: " + e.read())
        self.token = r['access_token']
        self.token_date = datetime.now()
        logging.info('QivivoAPI: token initialised with: ' + self.token)
        return

    def get_devices(self) ->[]:
        """
        return the device list of the account, refreshing it if necessary
        :return:
        """
        if not self.devices:
            self.refresh_devices()
        return self.devices['devices']

    def get_habitation(self) -> Habitation:
        """
        return the objet Habitation linked with the account
        :return:
        """
        return Habitation(self)

    def refresh_devices(self) -> None:
        """
        Refresh list of device from Qivivo resources server
        :return:
        """
        logging.info("QivivoAPI: getting devices")
        try:
            req = urllib.request.Request(self.api_url + 'devices',
                                         data=None,
                                         method='GET',
                                         headers={'Content-Type': 'application/json',
                                                  'Authorization': 'Bearer ' + self.token},)
        except urllib.error.HTTPError as e:
            logging.error("QivivoAPI: urllib error: " + e.reason)
            logging.error("QivivoAPI; API error: " + e.read())
        r = json.load(urllib.request.urlopen(req))
        self.devices = r
        return

    def get_device_by_uuid(self, uuid: str) -> Device:
        """
        Determine the type of device and return the object
        :param uuid:
        :return:
        """
        logging.info("QivivoAPI: getting device " + uuid + " infos")
        devtype = None
        for device in self.devices['devices']:
            if device['uuid'] == uuid:
                devtype = device['type']
        logging.info("QivivoAPI: Device " + uuid + " is a " + devtype)
        if devtype == 'thermostat':
            logging.info('QivivoAPI: Adding thermostat ' + uuid)
            return Thermostat(uuid, self)
        else:
            if devtype == 'gateway':
                logging.info('QivivoAPI: Adding gateway ' + uuid)
                return Gateway(uuid, self)
            else:
                if devtype == 'wireless-module':
                    logging.info('QivivoAPI: Adding wirless module ' + uuid)
                    return WirelessModule(uuid, self)
                else:
                    logging.error('QivivoAPI: Unsupported device')
                    return None

    def get_value(self, device_type: str, sub_type: str, uuid: str, value: str) -> {}:
        """
        Get value from resources server
        :param device_type:
        :param sub_type:
        :param uuid:
        :param value:
        :return:
        """
        self.check_token()
        if uuid:
            uuid = '/' + uuid
        else:
            uuid = ''
        logging.debug(
            "QivivoAPI: getting " + value + " for " + device_type + " " + sub_type + uuid + " from " + self.api_url)

        req = urllib.request.Request(self.api_url + device_type + '/' + sub_type + uuid + '/' + value,
                                     headers={'Content-Type': 'application/json',
                                              'Authorization': 'Bearer ' + self.token},
                                     method='GET')
        try:
            info = json.load(urllib.request.urlopen(req))
        except urllib.error.HTTPError as e:
            logging.error("QivivoAPI: urllib error: " + e.reason)
            logging.error("QivivoAPI; API error: " + e.read())
        return info

    def set_value(self, device_type: str, sub_type: str, uuid: str, value: str, data: json) -> {}:
        """
        Set value on resources server
        :param device_type:
        :param sub_type:
        :param uuid:
        :param value:
        :param data:
        :return:
        """
        self.check_token()
        if uuid:
            uuid = '/' + uuid
        else:
            uuid = ''
        logging.debug(
            "QivivoAPI: Setting " + value + " for " + device_type + " " + sub_type + uuid + " from " + self.api_url)
        req = urllib.request.Request(self.api_url + device_type + '/' + sub_type + '/' + uuid + '/' + value,
                                     headers={'Content-Type': 'application/json',
                                              'Authorization': 'Bearer ' + self.token},
                                     method='POST',
                                     data=json.dumps(data))
        try:
            info = json.load(urllib.request.urlopen(req))
        except urllib.error.HTTPError as e:
            logging.error("QivivoAPI: urllib error: " + e.reason)
            logging.error("QivivoAPI; API error: " + e.read())
        return info

    def del_value(self, device_type: str, sub_type: str, uuid: str, value: str) -> {}:
        """
        Delete value on resources server
        :param device_type:
        :param sub_type:
        :param uuid:
        :param value:
        :return:
        """
        self.check_token()
        if uuid:
            uuid = '/' + uuid
        else:
            uuid = ''
        logging.debug(
            "QivivoAPI: Deleting " + value + " for " + device_type + " " + sub_type + uuid + " from " + self.api_url)
        req = urllib.request.Request(self.api_url + device_type + '/' + sub_type + '/' + uuid + '/' + value,
                                     headers={'Content-Type': 'application/json',
                                              'Authorization': 'Bearer ' + self.token},
                                      method='DELETE')
        try:
            info = json.load(urllib.request.urlopen(req))
        except urllib.error.HTTPError as e:
            logging.error("QivivoAPI: urllib error: " + e.reason)
            logging.error("QivivoAPI; API error: " + e.read())
        return info

    def put_value(self, device_type: str, sub_type: str, uuid: str, value: str, data: str) -> {}:
        """
        Set value on resources server
        :param device_type:
        :param sub_type:
        :param uuid:
        :param value:
        :param data:
        :return:
        """
        self.check_token()
        if uuid:
            uuid = '/' + uuid
        else:
            uuid = ''
        logging.debug(
            "QivivoAPI: Setting " + value + " for " + device_type + " " + sub_type + uuid + " from " + self.api_url)
        req = urllib.request.Request(self.api_url + device_type + '/' + sub_type + '/' + uuid + '/' + value,
                                     headers={'Content-Type': 'application/json',
                                              'Authorization': 'Bearer ' + self.token},
                                     method='PUT',
                                     data=json.dumps(data))
        try:
            info = json.load(urllib.request.urlopen(req))
        except urllib.error.HTTPError as e:
            logging.error("QivivoAPI: urllib error: " + e.reason)
            logging.error("QivivoAPI; API error: " + str(e.read()))

        return info
